#ifndef CORROSION_SRC_PARSER_AST_TOKEN_HPP_
#define CORROSION_SRC_PARSER_AST_TOKEN_HPP_

#include "utility/fwd.hpp"

#include "span/span.hpp"
#include "span/symbol.hpp"

namespace corrosion::ast
{

	enum class TokenKind : uint32_t
	{
		/* Expression-operator symbols. */
		Eq,
		Lt,
		Le,
		EqEq,
		Ne,
		Ge,
		Gt,
		AndAnd,
		OrOr,
		Not,
		Tilde,
		BinOp,
		BinOpEq,

		/* Structural symbols */
		At,
		Dot,
		DotDot,
		DotDotDot,
		DotDotEq,
		Comma,
		Semi,
		Colon,
		ModSep,
		RArrow,
		LArrow,
		FatArrow,
		Pound,
		Dollar,
		Question,
		/// Used by proc macros for representing lifetimes, not generated by lexer right now.
		SingleQuote,
		/// An opening delimiter (e.g., `{`).
		OpenDelim,
		/// A closing delimiter (e.g., `}`).
		CloseDelim,

		/* Literals */
		Literal,

		/// Identifier token.
		/// Do not forget about `NtIdent` when you want to match on identifiers.
		/// It's recommended to use `Token::(ident,uninterpolate,uninterpolated_span)` to
		/// treat regular and interpolated identifiers in the same way.
		Ident,

		Type,
		/// Lifetime identifier token.
		/// Do not forget about `NtLifetime` when you want to match on lifetime identifiers.
		/// It's recommended to use `Token::(lifetime,uninterpolate,uninterpolated_span)` to
		/// treat regular and interpolated lifetime identifiers in the same way.
		Lifetime,

		//Interpolated,

//		// Can be expanded into several tokens.
//		/// A doc comment.
//		DocComment,

		// Junk. These carry no data because we don't really care about the data
		// they *would* carry, and don't really want to allocate a new ident for
		// them. Instead, users could extract that from the associated span.
		/// Whitespace.
		Whitespace,
		/// A comment.
		Comment,
		/// A completely invalid token which should be skipped.
		Unknown,

		Eof
	};
	namespace data
	{
		struct Delim
		{
			enum Kind
			{
				/// A round parenthesis (i.e., `(` or `)`).
				Paren,
				/// A square bracket (i.e., `[` or `]`).
				Bracket,
				/// A curly brace (i.e., `{` or `}`).
				Brace,
				/// An empty delimiter.
				NoDelim,
			} kind;

			std::size_t len() const noexcept
			{
				if (kind == Delim::Kind::NoDelim)
				{
					return 0;
				}
				return 1;
			}
			inline bool isEmpty() const noexcept
			{
				return kind == Delim::Kind::NoDelim;
			}
		};
		struct BinOp
		{
			enum Kind
			{
				Plus,
				Minus,
				Star,
				Slash,
				Percent,
				Caret,
				And,
				Or,
				Shl,
				Shr
			} kind;
		};

		struct Literal
		{
			enum Kind
			{
				Bool, // AST only, must never appear in a `Token`
				Byte,
				Char,
				Integer,
				Float,
				Str,
				Err,
			} kind;
			Symbol symbol;
			std::optional<Symbol> suffix;

			static std::string kindPrintable(const Literal& literal) noexcept
			{
				switch (literal.kind)
				{
				case Kind::Bool:
					return "bool";
				case Kind::Byte:
					return "byte";
				case Kind::Char:
					return "char";
				case Kind::Str:
					return "string";
				case Kind::Float:
					return "float";
				case Kind::Integer:
					return "integer";
				case Kind::Err:
					return "err";
				default:
					return "";
				}
			}
			bool mayHaveSuffix() const noexcept
			{
				if (kind == Kind::Integer || kind == Kind::Float || kind == Kind::Err)
				{
					return true;
				}
				return false;
			}
		};
		struct Ident
		{
			Symbol symbol;
			static bool identCanBeginExpr(Span span, Symbol symbol);
			static bool exprKeyword(Symbol symbol)
			{
				switch (kw(symbol.data()))
				{
				case kw::Async:
				case kw::Do:
				case kw::Box:
				case kw::Break:
				case kw::Continue:
				case kw::False:
				case kw::For:
				case kw::If:
				case kw::Let:
				case kw::Loop:
				case kw::Match:
				case kw::Move:
				case kw::Return:
				case kw::True:
				case kw::Unsafe:
				case kw::While:
				case kw::Yield:
				case kw::Static:
					return true;
				default:
					return false;
				}

			}
		};
		struct Lifetime
		{
			Symbol symbol;
		};
		struct Empty
		{

		};
	}
	using TokenData = std::variant<data::Delim,
								   data::BinOp,
								   data::Literal,
								   data::Ident,
								   data::Lifetime,
								   data::Empty>;

	struct Token
	{
		TokenKind kind;
		Span span;
		TokenData data;

	 public:
		Token(TokenKind kind = TokenKind::Whitespace, Span span = {}, TokenData data = data::Empty{}) :
			kind{ kind }, span{ span }, data{ data }
		{
		}
		bool isOp() const noexcept
		{
			switch (kind)
			{
			case TokenKind::OpenDelim:
			case TokenKind::CloseDelim:
			case TokenKind::Literal:
			case TokenKind::Comment:
			case TokenKind::Ident:
			case TokenKind::Lifetime:
			case TokenKind::Whitespace:
			case TokenKind::Eof:
				return false;
			default:
				return true;
			}
		}
		template<typename T>
		inline auto getData() const
		{
			return std::get<T>(data);
		}
		bool isLikePlus() const noexcept
		{
			if(kind == TokenKind::BinOp || kind==TokenKind::BinOpEq)
			{
				auto kind = std::get<data::BinOp>(data).kind;
				if(kind == data::BinOp::Kind::Plus)
				{
					return true;
				}
			}
			return false;
		}
		//! Returns `true` if the token can appear at the start of an expression.
		bool canBeginExpr() const noexcept
		{
			switch(kind)
			{
			case TokenKind::Ident: // value name or keyword
			{
				auto token_data = getData<data::Ident>();
				return data::Ident::identCanBeginExpr(span, token_data.symbol);
			}
			case TokenKind::OpenDelim:  // tuple, array or block
			case TokenKind::Literal: // literal
			case TokenKind::Not:  // operator not
				return true;
			case TokenKind::BinOp:
			{
				auto token_data = getData<data::BinOp>();
				switch(token_data.kind)
				{
				case data::BinOp::Minus:
				case data::BinOp::Star:
				case data::BinOp::Or: // closure
				case data::BinOp::And:
					return true;
				default:
					return false;
				}
			}
			case TokenKind::OrOr: // closure
			case TokenKind::AndAnd:  // double reference
				return true;



			case TokenKind::ModSep:
				return true;
			}
			return false;
		}

	};
}

#endif //CORROSION_SRC_PARSER_AST_TOKEN_HPP_
